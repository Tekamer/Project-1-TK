#include <crow.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/bn.h>
#include <nlohmann/json.hpp>
#include <unordered_map>
#include <chrono>
#include <iostream>
#include <string>
#include <memory>
#include <fstream>
#include <jwt-cpp/jwt.h>
#include <gtest/gtest.h>

using namespace std;
using json = nlohmann::json;

struct KeyPair {
    string kid;
    string public_key;
    string private_key;
    time_t expiry;
};

unordered_map<string, KeyPair> key_store;

string generate_kid() {
    return to_string(chrono::system_clock::now().time_since_epoch().count());
}

KeyPair generate_rsa_keypair() {
    RSA* rsa = RSA_new();
    BIGNUM* e = BN_new();
    BN_set_word(e, RSA_F4);
    RSA_generate_key_ex(rsa, 2048, e, NULL);
    
    BIO* pub = BIO_new(BIO_s_mem());
    PEM_write_bio_RSA_PUBKEY(pub, rsa);
    char* pub_key_cstr;
    size_t pub_len = BIO_get_mem_data(pub, &pub_key_cstr);
    string public_key(pub_key_cstr, pub_len);
    BIO_free(pub);
    
    BIO* priv = BIO_new(BIO_s_mem());
    PEM_write_bio_RSAPrivateKey(priv, rsa, NULL, NULL, 0, NULL, NULL);
    char* priv_key_cstr;
    size_t priv_len = BIO_get_mem_data(priv, &priv_key_cstr);
    string private_key(priv_key_cstr, priv_len);
    BIO_free(priv);
    
    RSA_free(rsa);
    BN_free(e);
    
    return {generate_kid(), public_key, private_key, time(nullptr) + 3600};
}

void refresh_keys() {
    KeyPair keypair = generate_rsa_keypair();
    key_store[keypair.kid] = keypair;
}

json get_jwks() {
    json jwks;
    jwks["keys"] = json::array();
    for (const auto& [kid, keypair] : key_store) {
        if (keypair.expiry > time(nullptr)) {
            jwks["keys"].push_back({{"kid", kid}, {"kty", "RSA"}, {"alg", "RS256"}, {"use", "sig"}, {"n", keypair.public_key}, {"e", "AQAB"}});
        }
    }
    return jwks;
}

string generate_jwt(const KeyPair& keypair, bool expired) {
    auto token = jwt::create()
        .set_issuer("jwks-server")
        .set_type("JWT")
        .set_payload_claim("user", jwt::claim(string("test-user")))
        .set_expires_at(chrono::system_clock::now() + chrono::seconds(expired ? -3600 : 3600))
        .set_key_id(keypair.kid)
        .sign(jwt::algorithm::rs256("", keypair.private_key, "", ""));
    return token;
}

// Google Test cases
TEST(KeyGenerationTest, GenerateRSAKeypair) {
    KeyPair keypair = generate_rsa_keypair();
    EXPECT_FALSE(keypair.public_key.empty());
    EXPECT_FALSE(keypair.private_key.empty());
    EXPECT_FALSE(keypair.kid.empty());
}

TEST(JWKSTest, JWKSResponseFormat) {
    refresh_keys();
    json jwks = get_jwks();
    EXPECT_TRUE(jwks.contains("keys"));
    EXPECT_GT(jwks["keys"].size(), 0);
}

TEST(JWTTest, GenerateJWT) {
    refresh_keys();
    auto it = key_store.begin();
    string token = generate_jwt(it->second, false);
    EXPECT_FALSE(token.empty());
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
